/***********************************************************************	Author: Amith Tudur 	This file is part of Weawars.    Weawars is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    Weawars is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with Weawars.  If not, see <http://www.gnu.org/licenses/>.***********************************************************************/package  {	import flash.display.*;	import flash.events.Event;	import fl.motion.MatrixTransformer;	import flash.geom.Matrix;	import flash.utils.Timer;	import Range;	import Monsters;	import flash.geom.Point;	import TankTex;	import Cannon;	import flash.events.TimerEvent;		public class Tower extends Sprite{		private var i:int, j:int;		private var gx:Number, gy:Number, gsize:Number;		private var cannon:Cannon;		private var deg:Number;		private var range:Range;		private var fireFrequency:Number;		private var fireTimer:Timer;		private var power:Number; //how much damage is dealt per shot		private var monsterset:Monsters;		private var currentCreature:Creature;		private static const DEAD:int  = 0;		private static const ALIVE:int = 1;		private static const STORE:int = 2;		private var currentDir:Point;		private var newmonsterset:Boolean;				public function Tower( l_range:Range, l_monsters:Monsters, l_gsize:Number) {			gsize 			= l_gsize;			range 			= l_range;			monsterset 		= l_monsters;			currentCreature = null;			range.alpha 	= 0.5; //for debugging..			fireFrequency 	= 3.0 //shots per second				power			= 60/fireFrequency; //determines the dps - damage per second						newmonsterset	= false;			deg = 0;			cannon = new Cannon( gsize);			addChild( cannon );			currentDir = new Point(gsize, gsize/2 ); //@0deg		}				public function fireNow( eve:TimerEvent ){			cannon.fire( currentCreature.getPos( ), 3 );			currentCreature.doDamage( power );		}		public function enableResponse( ){			fireTimer		= new Timer( (1.0/fireFrequency)*1000 ); //repeat until stopped			fireTimer.addEventListener( TimerEvent.TIMER, fireNow, false, 0, true);			addEventListener( Event.ENTER_FRAME, monsterResponse, false, 0, true );					}				public function disableResponse(  ){			if( fireTimer )				fireTimer.stop( ); //ceasefire			removeEventListener( Event.ENTER_FRAME, monsterResponse );		}				public function updateMonsterset( l_monsters:Monsters ){			newmonsterset = true;			monsterset 	  = l_monsters;		}				public function monsterResponse( eve:Event ){			var p:Point, newDir:Point, theta:Number;						if( !currentCreature ){				var i:int;				var creature:Creature;				for( i=0; i<monsterset.monsters.length; i++){					if( newmonsterset ){						newmonsterset = false;						break;					}					creature = monsterset.monsters[i];					if( creature.creatureState == STORE || creature.creatureState == ALIVE ){						if( withinRange( creature.getPos( ) ) ){							currentCreature 	= creature;							fireTimer.start( );							break;						}					}				}			}						if( currentCreature ){				var creatureActive:Boolean = false;				if( currentCreature.creatureState == ALIVE ){					if( withinRange( currentCreature.getPos( ) ) ){ 						p 			= globalToLocal(currentCreature.getPos( ));												newDir 		= new Point( p.x - gsize/2, p.y - gsize/2 );						theta		= Math.atan2( newDir.y, newDir.x) - Math.atan2(currentDir.y,currentDir.x);						cannon.rotateAboutCenter( theta*180/Math.PI );						currentDir = newDir;						creatureActive = true;					}				}				if( !creatureActive ){					currentCreature = null;					fireTimer.stop( );				}			}					}				private function withinRange( p:Point ){			var lp:Point = globalToLocal( p );			var dist:Number = Math.sqrt( (lp.x-x)*(lp.x-x) + (lp.y-y)*(lp.y-y) );			if( dist <= 3*gsize ) //range = 3*grid_size				return true;			return false;		}				public function placeTower( li:int, lj:int, lx:Number, ly:Number){			i = li; j = lj; gx = lx; gy = ly;		}	}	}