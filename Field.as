package  {	import flash.display.*;	import Grid;	import Monsters;	import Game;	import BGTex;	import PathTex;		public class Field extends Sprite{		public var grid_m:Number;		public var grid_n:Number;		public var grid_size:Number;		private var canvas:Shape, grid_bg:Shape;		private var color:Number;		private var battleGrid:Array;		private var i:Number, j:Number;		public var begin_x:Number, begin_y:Number;		private var stage_v:Stage;		private static const CANVAS_CLR = 0xFFCC99;		private static const GRIDBG_CLR = 0xFFCCCC;		private static const MPATH_CLR	= 0xFFFFFF;		public static const PLACEMENT	= 4;		public static const COMBAT		= 5;		public static const NOCHANGE	= 6;		public var fieldmode:int; //holds one of PLACEMENT or COMBAT		public var monsters:Monsters;		public var game:Game;				public function Field( l_game:Game, l_stage:Stage ) {			game 		= l_game;			stage_v 	= l_stage;			grid_m 		= game.grid_m;			grid_n 		= game.grid_n; 			grid_size 	= game.grid_size;			fieldmode	= PLACEMENT;						var bg:BGTex = new BGTex( );			bg.x 	 = 0; bg.y = 0;			bg.width = grid_m*grid_size; bg.height = grid_n*grid_size;			addChild( bg );						begin_x	  = 0;			begin_y	  = 0;			var v_horiz:PathTex = new PathTex( );			v_horiz.x = begin_x;			v_horiz.y = begin_y+(grid_n*grid_size)/2-grid_size;			v_horiz.width = grid_m*grid_size;			v_horiz.height = 3*grid_size;			addChild( v_horiz );						var v_vert:PathTex = new PathTex( );			v_vert.x = begin_x+((grid_m*grid_size/2)-grid_size);			v_vert.y = begin_y;			v_vert.width = 3*grid_size;			v_vert.height = grid_n*grid_size			addChild( v_vert );						v_horiz.alpha = v_vert.alpha = 0.5;						battleGrid = new Array( );			for( i=0; i<grid_m ; i++ ){				battleGrid.push( new Array() );				for( j=0; j<grid_n; j++){					color = GRIDBG_CLR; //same as the BG color;					battleGrid[i].push( new Grid(this,i,j,begin_x+i*grid_size,begin_y+j*grid_size,grid_size, color) );					addChild( battleGrid[i][j] );				}			}		}				public function reset( ){			removeTowers( );			unsetMonsters( );			fieldmode	= PLACEMENT;		}				public function addTower( ){			if( game.player.money >= 10 ){				game.player.updateMoney( -10 );				enablePlacement( );			}else{				trace( 'not enough money left ::' + game.player.money );			}		}				public function removeTowers( ){			var i:int, j:int;			for( i=0; i<grid_m; i++)				for( j=0; j<grid_n; j++)					if( battleGrid[i][j].hasTower )						battleGrid[i][j].removeTower( );		}				public function enablePlacement( ){			var i:int, j:int;			for( i=0; i<grid_m; i++){				for( j=0; j<grid_n; j++)					battleGrid[i][j].placeTower( );			}		}				public function setMonsters( l_monsters:Monsters ){			monsters = l_monsters;			var i:int, j:int;			for( i=0; i<grid_m; i++){				for( j=0; j<grid_n; j++){					if( battleGrid[i][j].hasTower ){	//if there is a tower present already						battleGrid[i][j].tower.updateMonsterset( monsters );					}					battleGrid[i][j].monsters = monsters;				}			}		}				public function unsetMonsters( ){			var i:int, j:int;			for( i=0; i<grid_m; i++){				for( j=0; j<grid_n; j++)					battleGrid[i][j].monsters = null;			}		}				public function disablePlacement( ){			var i:int, j:int;			for( i=0; i<grid_m; i++){				for( j=0; j<grid_n; j++)					battleGrid[i][j].stopPlacement( );			}		}				public function enableTowerRange( ){			var i:int, j:int;			for( i=0; i<grid_m; i++){				for( j=0; j<grid_n; j++)					battleGrid[i][j].enableRange( );			}		}				public function disableTowerRange( ){			var i:int, j:int;			for( i=0; i<grid_m; i++){				for( j=0; j<grid_n; j++){					battleGrid[i][j].disableRange( );					if( battleGrid[i][j].hasTower )						battleGrid[i][j].tower.disableResponse( );				}			}					}	}	}