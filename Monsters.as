package{	import Creature;	import Field;	import flash.display.*;	import flash.events.Event;	import flash.utils.*;		public class Monsters extends Sprite{		public  var num:int; //number of monsters left		private var maxnum:int; //number of monsters to spawn		public  var monsters:Array;		private var monstersAdded:int;		private static const DEAD:int  = 0;		private static const ALIVE:int = 1;		private static const STORE:int = 2;				private static const GRP_ACTIVE:int 	= 4;		private static const GRP_INACTIVE:int	= 5;				private var grid_m:Number, grid_n:Number,					grid_size:Number;		private var field:Field;		public  var game:Game;		public  var waves:Waves;		private static const spawnMinTime = 500; //ms		private static const spawnMaxTime = 1000; //ms		private var spawnTimer:Timer;				public function Monsters(l_waves:Waves, l_game:Game, l_num:int ){			var i:int, spx:Number, spy:Number,				epx:Number, epy:Number, dir:int;			game			= l_game;			waves			= l_waves;			grid_m			= game.grid_m;			grid_n			= game.grid_n;			grid_size		= game.grid_size;			field			= game.field;						monsters 		= new Array( );			monstersAdded	= 0;			maxnum 			= l_num;			num				= maxnum;			for( i=0; i<maxnum; i++ ){				if( i < maxnum/2 ){ //spawn along the [x] direction					dir = 1;					spx = field.begin_x;					spy = field.begin_y+ (grid_n/2*grid_size + choice(-1,1)*grid_size);					epx = field.begin_x+ ((grid_m)*grid_size);					epy = spy;				}else{	//spawn along the [y] direction					dir = 0;					spy = field.begin_y;					spx = field.begin_x+ (grid_m/2*grid_size + choice(-1,1)*grid_size);					epx = spx;					epy = field.begin_y+ ((grid_n)*grid_size);				}				monsters.push( new Creature( this, spx, spy,epx, epy, dir, 'monster-'+i) );				addChild( monsters[i] );			}			addEventListener( Event.ENTER_FRAME, checkForTermination, false, 0, true );		}				public function checkForTermination( eve:Event ){			if( num <= 0 ){				removeEventListener( Event.ENTER_FRAME, checkForTermination );				removeFromField( );				waves.nextWave( );			}		}				public function addToField( ){			spawnTimer = new Timer( choice(spawnMinTime,spawnMaxTime)); //delay between .5 to 1 sec			spawnTimer.addEventListener("timer", introduce, false, 0, true );			spawnTimer.start();		}				public function removeFromField( ){			var numCh:Number = numChildren;			for (var i:int =1; i <= numCh; i++){  				var creature:Creature = getChildAt(0) as Creature;				creature.clearCreature( );								removeChild( creature );			}			if( parent )				parent.removeChild( this );		}				private function introduce( eve:Event ){			do{				if( monstersAdded >= maxnum )					break;				var index:int = choice( 0, maxnum-1 );			}while( !(monsters[index].creatureState == STORE) );			monsters[index].addToField( );			monstersAdded += 1;			if( monstersAdded >= maxnum ){				removeEventListener( Event.ENTER_FRAME, introduce ); //done with introducing the monsters.				spawnTimer.stop( );			}else{				spawnTimer.stop( );				spawnTimer = new Timer(  choice(spawnMinTime,spawnMaxTime)); //delay between .5 to 1 sec				spawnTimer.addEventListener("timer", introduce, false, 0, true );				spawnTimer.start();			}		}				private function choice(low:Number=0, high:Number=1):Number		{  			return Math.floor(Math.random() * (1+high-low)) + low;		}	}	}